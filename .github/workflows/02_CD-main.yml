name : CD - Pipeline
on:
  workflow_run:
    workflows: ["CI - Code Quality"]
    types: [completed]
    branches: [main, dev, staging]

  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        type: choice
        options: [dev, staging, prod]
      action:
        description: 'Action to Perform'
        required: true
        type: choice
        options: [deploy, plan-only, destroy, bootstrap-only]
      reason:
        description: 'Reason for Manual Trigger (Required for prod)'
        required: false
        type: string

  schedule:
    - cron: '0 6 * * *'

concurrency:
  group: cd-${{ github.workflow }}-${{ github.event.inputs.environment || github.ref_name }}
  cancel-in-progress: false

env:
  TERRAFORM_VERSION: "~> 1.10"
  AWS_REGION: ap-south-1
  TF_LOCK_TIMEOUT: "300s"
  TF_REGISTRY_CLIENT_TIMEOUT: "30"
  PROJECT_NAME: "cdc-pipeline"
  TF_PLUGIN_CACHE_DIR: ~/.terraform.d/plugin-cache

jobs:
  ci-check:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run'
    timeout-minutes: 5

    steps:
      - name: Check CI Status
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "CI workflow failed - blocking deployment"
            echo "Workflow: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            exit 1
          fi
          echo "CI workflow passed - proceeding with deployment"

  pre-check:
    runs-on: ubuntu-latest
    
    timeout-minutes: 5

    outputs:
      env: ${{ steps.env.outputs.env }}
      bucket: ${{ steps.env.outputs.bucket }}
      table: ${{ steps.env.outputs.table }}
      aws_access_key: ${{ steps.env.outputs.aws_access_key }}
      aws_secret_key: ${{ steps.env.outputs.aws_secret_key }}
      is_manual: ${{ steps.env.outputs.is_manual }}
      drift_check: ${{ steps.env.outputs.drift_check }}
      # ci_passed is set by either ci-check or ci-check-skipped step
      ci_passed: ${{ steps.ci-check.outputs.ci_passed || steps['ci-check-skipped'].outputs.ci_passed || 'true' }}

    steps:
      # CI Check step - runs only on workflow_run (auto-trigger)
      - name: Check CI Status
        id: ci-check
        if: github.event_name == 'workflow_run'
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "CI workflow failed - blocking deployment"
            echo "Workflow: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "ci_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "CI workflow passed - proceeding with deployment"
          echo "ci_passed=true" >> $GITHUB_OUTPUT

      # Skip CI check for manual triggers - set ci_passed=true
      - name: CI Check Skipped (Manual Trigger)
        id: ci-check-skipped
        if: github.event_name != 'workflow_run'
        run: |
          echo "Manual trigger detected - skipping CI check"
          echo "ci_passed=true" >> $GITHUB_OUTPUT

      - name: Determine Environment & Context
        id: env
        run: |
          set -euo pipefail

          IS_MANUAL="false"
          DRIFT_CHECK="false"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            IS_MANUAL="true"
            ENV="${{ github.event.inputs.environment }}"

            if [[ ! "$ENV" =~ ^(dev|staging|prod)$ ]]; then
              echo "Invalid environment: $ENV"
              exit 1
            fi

            if [ "$ENV" = "prod" ] && [ -z "${{ github.event.inputs.reason }}" ]; then
              echo "Production deployments require a reason"
              exit 1
            fi

          elif [ "${{ github.event_name }}" = "schedule" ]; then
            DRIFT_CHECK="true"
            ENV="prod"

            
          else
            BRANCH="${GITHUB_REF##*/}"
            case "$BRANCH" in
              dev)
                ENV="dev"
                ;;
              staging)
                ENV="staging"
                ;;
              main|master)
                ENV="prod"
                ;;
              *)
                echo "Unknown branch '$BRANCH', defaulting to dev"
                ENV="dev"
                ;;
            esac
          fi

          echo "Target Environment: $ENV"
          echo "Manual Trigger: $IS_MANUAL"
          echo "Drift Check: $DRIFT_CHECK"

          echo "env=$ENV" >> $GITHUB_OUTPUT
          echo "is_manual=$IS_MANUAL" >> $GITHUB_OUTPUT
          echo "drift_check=$DRIFT_CHECK" >> $GITHUB_OUTPUT
          echo "bucket=cdc-pipeline-tfstate-$ENV" >> $GITHUB_OUTPUT
          echo "table=cdc-pipeline-terraform-lock-$ENV" >> $GITHUB_OUTPUT

          case "$ENV" in
            dev)
              echo "aws_access_key=AWS_DEV_ACCESS_KEY_ID" >> $GITHUB_OUTPUT
              echo "aws_secret_key=AWS_DEV_SECRET_ACCESS_KEY" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "aws_access_key=AWS_STAGING_ACCESS_KEY_ID" >> $GITHUB_OUTPUT
              echo "aws_secret_key=AWS_STAGING_SECRET_ACCESS_KEY" >> $GITHUB_OUTPUT
              ;;
            prod)
              echo "aws_access_key=AWS_PROD_ACCESS_KEY_ID" >> $GITHUB_OUTPUT
              echo "aws_secret_key=AWS_PROD_SECRET_ACCESS_KEY" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Log Configuration
        run: |
          echo "=========================================="
          echo "Deployment Configuration"
          echo "=========================================="
          echo "Environment: ${{ steps.env.outputs.env }}"
          echo "S3 Bucket: ${{ steps.env.outputs.bucket }}"
          echo "DynamoDB Table: ${{ steps.env.outputs.table }}"
          echo "Is Manual: ${{ steps.env.outputs.is_manual }}"
          echo "Drift Check: ${{ steps.env.outputs.drift_check }}"
          echo "Triggered by: ${{ github.event_name }}"
          if [ -n "${{ github.event.inputs.reason || '' }}" ]; then
            echo "Reason: ${{ github.event.inputs.reason }}"
          fi
          echo "=========================================="

  terraform-bootstrap:
    needs: pre-check
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.pre-check.result == 'success' &&
      needs.pre-check.outputs.drift_check != 'true' &&
      (github.event_name == 'workflow_run' ||
       github.event.inputs.action == 'deploy' ||
       github.event.inputs.action == 'plan-only' ||
       github.event.inputs.action == 'bootstrap-only')
    timeout-minutes: 15

    outputs:
      bootstrap_status: ${{ steps.set-status.outputs.bootstrap_status }}
      bucket_exists: ${{ steps.check.outputs.exists }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Prepare Plugin Cache
        run: mkdir -p ${{ env.TF_PLUGIN_CACHE_DIR }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets[needs.pre-check.outputs.aws_access_key] }}
          aws-secret-access-key: ${{ secrets[needs.pre-check.outputs.aws_secret_key] }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS Access
        run: |
          echo "Verifying AWS credentials..."
          aws sts get-caller-identity
          echo "AWS access verified"

      - name: Check Existing Resources
        id: check
        run: |
          set -e
          BUCKET="${{ needs.pre-check.outputs.bucket }}"
          TABLE="${{ needs.pre-check.outputs.table }}"

          echo "Checking backend resources..."

          BUCKET_EXISTS="false"
          TABLE_EXISTS="false"

          if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "S3 bucket exists: $BUCKET"
            BUCKET_EXISTS="true"
          else
            echo "S3 bucket missing: $BUCKET"
          fi

          if aws dynamodb describe-table --table-name "$TABLE" --region ${{ env.AWS_REGION }} 2>/dev/null >/dev/null; then
            echo "DynamoDB table exists: $TABLE"
            TABLE_EXISTS="true"
          else
            echo "DynamoDB table missing: $TABLE"
          fi

          if [ "$BUCKET_EXISTS" = "true" ] && [ "$TABLE_EXISTS" = "true" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Bootstrap Terraform
        if: steps.check.outputs.exists == 'false'
        id: bootstrap-apply
        working-directory: terraform-bootstrap
        run: |
          ENV="${{ needs.pre-check.outputs.env }}"
          
          echo "Initializing bootstrap Terraform..."
          terraform init -input=false

          echo "Planning bootstrap..."
          terraform plan \
            -out=tfplan-bootstrap \
            -input=false \
            -var="environment=$ENV" \
            -var="bucket_name=${{ needs.pre-check.outputs.bucket }}" \
            -var="dynamodb_table_name=${{ needs.pre-check.outputs.table }}" \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -lock-timeout=${{ env.TF_LOCK_TIMEOUT }}

          echo "Applying bootstrap..."
          terraform apply \
            -auto-approve \
            -lock-timeout=${{ env.TF_LOCK_TIMEOUT }} \
            tfplan-bootstrap

      - name: Wait for AWS Propagation
        if: steps.check.outputs.exists == 'false'
        run: |
          echo "Waiting for AWS propagation..."
          for i in 1 2 3 4 5; do
            if aws s3api head-bucket --bucket "${{ needs.pre-check.outputs.bucket }}" 2>/dev/null; then
              echo "Bucket confirmed ready"
              exit 0
            fi
            echo "Waiting for bucket... attempt $i/5"
            sleep 5
          done
          echo "Timeout waiting for bucket propagation"
          exit 1

      - name: Set Bootstrap Status
        id: set-status
        run: |
          if [ "${{ steps.check.outputs.exists }}" = "true" ]; then
            echo "bootstrap_status=skipped_existing" >> $GITHUB_OUTPUT
            echo "Bootstrap skipped - resources already exist"
          elif [ "${{ steps.bootstrap-apply.outcome }}" = "success" ]; then
            echo "bootstrap_status=created" >> $GITHUB_OUTPUT
            echo "Bootstrap completed successfully"
          else
            echo "bootstrap_status=failed" >> $GITHUB_OUTPUT
            echo "Bootstrap failed"
            exit 1
          fi

  terraform-plan:
    needs: [pre-check, terraform-bootstrap]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.terraform-bootstrap.result == 'success' &&
      (github.event_name == 'workflow_run' ||
       github.event.inputs.action == 'deploy' ||
       github.event.inputs.action == 'plan-only' ||
       github.event.inputs.action == 'bootstrap-only' ||
       needs.pre-check.outputs.drift_check == 'true')
    timeout-minutes: 30

    outputs:
      has_changes: ${{ steps.plan.outputs.has_changes }}
      plan_id: ${{ steps.plan.outputs.plan_id }}
      drift_detected: ${{ steps.plan.outputs.drift_detected }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Prepare Plugin Cache
        run: mkdir -p ${{ env.TF_PLUGIN_CACHE_DIR }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Setup Infracost
        if: vars.INFRACOST_API_KEY != ''
        uses: infracost/actions/setup@v2
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets[needs.pre-check.outputs.aws_access_key] }}
          aws-secret-access-key: ${{ secrets[needs.pre-check.outputs.aws_secret_key] }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        id: init
        working-directory: terraform
        continue-on-error: true
        run: |
          echo "Initializing Terraform..."
          terraform init \
            -backend-config="bucket=${{ needs.pre-check.outputs.bucket }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ needs.pre-check.outputs.table }}" \
            -backend-config="encrypt=true" \
            -lock-timeout=${{ env.TF_LOCK_TIMEOUT }}

      - name: Terraform Init Retry
        if: steps.init.outcome == 'failure'
        working-directory: terraform
        run: |
          echo "Init failed, retrying in 20s..."
          sleep 20
          terraform init \
            -backend-config="bucket=${{ needs.pre-check.outputs.bucket }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ needs.pre-check.outputs.table }}" \
            -backend-config="encrypt=true" \
            -lock-timeout=${{ env.TF_LOCK_TIMEOUT }}

      - name: Terraform Format Check
        working-directory: terraform
        run: |
          echo "Checking Terraform formatting..."
          terraform fmt -check -recursive

      - name: Terraform Validate
        working-directory: terraform
        run: |
          echo "Validating Terraform configuration..."
          terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: terraform
        run: |
          ENV="${{ needs.pre-check.outputs.env }}"
          IS_DRIFT="${{ needs.pre-check.outputs.drift_check }}"
          PLAN_ID="tfplan-${ENV}-${{ github.run_id }}"

          echo "Generating Terraform plan..."

          set +e
          terraform plan \
            -out=${PLAN_ID} \
            -var="environment=${ENV}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="public_key=${{ secrets.SSH_PUBLIC_KEY }}" \
            -lock-timeout=${{ env.TF_LOCK_TIMEOUT }} \
            -detailed-exitcode 2>&1 | tee plan_raw.log

          EXIT_CODE=${PIPESTATUS[0]}
          set -e

          sed 's/[0-9a-fA-F]\{32,\}/****REDACTED****/g' plan_raw.log > plan.log

          case $EXIT_CODE in
            0)
              echo "No changes detected"
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "drift_detected=false" >> $GITHUB_OUTPUT
              ;;
            1)
              echo "Plan failed"
              cat plan.log
              exit 1
              ;;
            2)
              echo "Changes detected"
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "plan_id=${PLAN_ID}" >> $GITHUB_OUTPUT

              if [ "$IS_DRIFT" = "true" ]; then
                echo "drift_detected=true" >> $GITHUB_OUTPUT
                echo "DRIFT DETECTED in scheduled check!"
              else
                echo "drift_detected=false" >> $GITHUB_OUTPUT
              fi

              terraform show -no-color ${PLAN_ID} > plan_summary.txt
              ;;
          esac

      - name: Generate Plan Comment
        if: steps.plan.outputs.has_changes == 'true'
        working-directory: terraform
        run: |
          cat << 'EOF' > plan_comment.md
          ## Terraform Plan Summary
          
          **Environment:** ${{ needs.pre-check.outputs.env }}
          **Run ID:** ${{ github.run_id }}
          **Triggered by:** ${{ github.event_name }}
          
          <details><summary>Click to expand plan details</summary>
          
          ```terraform
          $(head -200 plan_summary.txt)
          ```
          
          </details>
          EOF

      - name: Infracost Breakdown
        if: steps.plan.outputs.has_changes == 'true' && vars.INFRACOST_API_KEY != ''
        working-directory: terraform
        continue-on-error: true
        run: |
          echo "Generating cost estimate..."
          infracost breakdown \
            --path . \
            --format json \
            --out-file infracost.json

          infracost output \
            --path infracost.json \
            --format github-comment \
            --out-file infracost_comment.md

      - name: Upload Plan Artifacts
        if: steps.plan.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.plan.outputs.plan_id }}
          path: |
            terraform/${{ steps.plan.outputs.plan_id }}
            terraform/plan_summary.txt
            terraform/plan_comment.md
            terraform/infracost_comment.md
          retention-days: 5
          if-no-files-found: warn

      - name: Drift Detection Alert
        if: steps.plan.outputs.drift_detected == 'true'
        run: |
          echo "INFRASTRUCTURE DRIFT DETECTED"
          echo "=========================================="
          echo "Environment: ${{ needs.pre-check.outputs.env }}"
          echo "Manual intervention required"
          echo "Review the plan artifacts for details"
          echo "=========================================="
          exit 1

  terraform-apply:
    needs: [terraform-plan, pre-check, terraform-bootstrap]
    runs-on: ubuntu-latest
    # CRITICAL: Only apply on MANUAL workflow_dispatch with action=deploy
    # Auto-trigger (workflow_run) is PLAN-ONLY, never auto-apply
    if: |
      needs.terraform-plan.outputs.has_changes == 'true' &&
      needs.pre-check.outputs.drift_check != 'true' &&
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.action == 'deploy'
    timeout-minutes: 45

    environment:
      name: ${{ needs.pre-check.outputs.env }}
      url: ${{ steps.outputs.outputs.service_url }}

    steps:
      - name: Deployment Context
        run: |
          echo "=========================================="
          echo "Starting deployment to ${{ needs.pre-check.outputs.env }}"
          echo "=========================================="
          if [ "${{ needs.pre-check.outputs.is_manual }}" = "true" ]; then
            echo "Manual trigger reason: ${{ github.event.inputs.reason }}"
          fi

      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Prepare Plugin Cache
        run: mkdir -p ${{ env.TF_PLUGIN_CACHE_DIR }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets[needs.pre-check.outputs.aws_access_key] }}
          aws-secret-access-key: ${{ secrets[needs.pre-check.outputs.aws_secret_key] }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ needs.pre-check.outputs.bucket }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ needs.pre-check.outputs.table }}" \
            -backend-config="encrypt=true" \
            -lock-timeout=${{ env.TF_LOCK_TIMEOUT }}

      - name: Backup State
        working-directory: terraform
        run: |
          echo "Creating state backup..."
          terraform state pull > state-backup-${{ github.run_id }}.json
          
          if [ ! -s state-backup-${{ github.run_id }}.json ]; then
            echo "Warning: State backup is empty"
          else
            echo "State backup created successfully"
          fi

      - name: Upload State Backup
        uses: actions/upload-artifact@v4
        with:
          name: state-backup-${{ needs.pre-check.outputs.env }}-${{ github.run_id }}
          path: terraform/state-backup-${{ github.run_id }}.json
          retention-days: 30

      - name: Download Plan Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.terraform-plan.outputs.plan_id }}
          path: terraform

      - name: Terraform Apply
        id: apply
        working-directory: terraform
        run: |
          PLAN_FILE="${{ needs.terraform-plan.outputs.plan_id }}"

          echo "Applying plan: ${PLAN_FILE}"

          terraform apply -auto-approve -lock-timeout=${{ env.TF_LOCK_TIMEOUT }} ${PLAN_FILE}

      - name: Capture Outputs
        id: outputs
        working-directory: terraform
        run: |
          echo "Deployment Outputs:"
          terraform output -json 2>/dev/null | jq . || echo "{}"

          SERVICE_URL=$(terraform output -raw service_url 2>/dev/null || echo "")
          DB_ENDPOINT=$(terraform output -raw database_endpoint 2>/dev/null || echo "")

          if [ -n "$SERVICE_URL" ]; then
            echo "service_url=${SERVICE_URL}" >> $GITHUB_OUTPUT
            echo "Service URL: ${SERVICE_URL}"
          fi
          if [ -n "$DB_ENDPOINT" ]; then
            echo "db_endpoint=${DB_ENDPOINT}" >> $GITHUB_OUTPUT
            echo "Database: ${DB_ENDPOINT}"
          fi

      - name: Deployment Success Notification
        if: success()
        run: |
          echo "=========================================="
          echo "Deployment successful!"
          echo "=========================================="
          echo "Environment: ${{ needs.pre-check.outputs.env }}"
          if [ -n "${{ steps.outputs.outputs.service_url }}" ]; then
            echo "Service URL: ${{ steps.outputs.outputs.service_url }}"
          fi
          echo "=========================================="

  terraform-destroy:
    needs: pre-check
    if: |
      github.event.inputs.action == 'destroy' &&
      needs.pre-check.outputs.env != 'prod' &&
      needs.pre-check.outputs.drift_check != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    environment:
      name: ${{ needs.pre-check.outputs.env }}-destroy

    steps:
      - name: Destroy Warning
        run: |
          echo "DESTROYING INFRASTRUCTURE"
          echo "=========================================="
          echo "Environment: ${{ needs.pre-check.outputs.env }}"
          echo "This action is IRREVERSIBLE!"
          echo "=========================================="

      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Prepare Plugin Cache
        run: mkdir -p ${{ env.TF_PLUGIN_CACHE_DIR }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets[needs.pre-check.outputs.aws_access_key] }}
          aws-secret-access-key: ${{ secrets[needs.pre-check.outputs.aws_secret_key] }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ needs.pre-check.outputs.bucket }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ needs.pre-check.outputs.table }}" \
            -backend-config="encrypt=true" \
            -lock-timeout=${{ env.TF_LOCK_TIMEOUT }}

      - name: Backup State Before Destroy
        working-directory: terraform
        run: |
          echo "Backing up state before destroy..."
          terraform state pull > state-before-destroy-${{ github.run_id }}.json

      - name: Upload Pre-Destroy State
        uses: actions/upload-artifact@v4
        with:
          name: state-before-destroy-${{ needs.pre-check.outputs.env }}-${{ github.run_id }}
          path: terraform/state-before-destroy-${{ github.run_id }}.json
          retention-days: 90

      - name: Terraform Destroy
        working-directory: terraform
        run: |
          ENV="${{ needs.pre-check.outputs.env }}"
          echo "Destroying infrastructure..."
          terraform destroy \
            -auto-approve \
            -var="environment=${ENV}" \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -lock-timeout=${{ env.TF_LOCK_TIMEOUT }}

      - name: Destroy Complete
        run: |
          echo "=========================================="
          echo "Infrastructure destroyed"
          echo "Environment: ${{ needs.pre-check.outputs.env }}"
          echo "=========================================="

  prod-destroy-blocker:
    needs: pre-check
    if: |
      github.event.inputs.action == 'destroy' &&
      needs.pre-check.outputs.env == 'prod'
    runs-on: ubuntu-latest

    steps:
      - name: Block Production Destroy
        run: |
          echo "PRODUCTION DESTROY BLOCKED"
          echo "=========================================="
          echo "This action is not allowed via workflow."
          echo ""
          echo "Manual steps required:"
          echo "1. Elevate to break-glass role"
          echo "2. Disable termination protection manually"
          echo "3. Run destroy from secure admin terminal"
          echo "4. Document in change log"
          echo ""
          echo "Event logged for security audit."
          echo "=========================================="
          exit 1

  notify:
    needs: [terraform-plan, pre-check]
    if: always() && needs.pre-check.result == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Determine Status
        id: status
        run: |
          # Check terraform-apply result (may be skipped if manual trigger not used)
          APPLY_RESULT="${{ needs.terraform-apply.result }}"
          PLAN_RESULT="${{ needs.terraform-plan.result }}"
          HAS_CHANGES="${{ needs.terraform-plan.outputs.has_changes }}"
          DRIFT_DETECTED="${{ needs.terraform-plan.outputs.drift_detected }}"
          
          if [ "$APPLY_RESULT" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Deployment applied successfully" >> $GITHUB_OUTPUT
          elif [ "$APPLY_RESULT" = "failure" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=Deployment failed" >> $GITHUB_OUTPUT
          elif [ "$DRIFT_DETECTED" = "true" ]; then
            echo "status=drift" >> $GITHUB_OUTPUT
            echo "message=Infrastructure drift detected" >> $GITHUB_OUTPUT
          elif [ "$PLAN_RESULT" = "skipped" ]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "message=Plan skipped" >> $GITHUB_OUTPUT
          elif [ "$HAS_CHANGES" = "true" ]; then
            echo "status=pending" >> $GITHUB_OUTPUT
            echo "message=Plan created - manual apply required" >> $GITHUB_OUTPUT
          elif [ "$PLAN_RESULT" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=No changes detected - infrastructure up to date" >> $GITHUB_OUTPUT
          else
            echo "status=info" >> $GITHUB_OUTPUT
            echo "message=Workflow completed" >> $GITHUB_OUTPUT
          fi

      - name: Send Notification
        run: |
          echo "=========================================="
          echo "CD Workflow Notification"
          echo "=========================================="
          echo "Status: ${{ steps.status.outputs.status }}"
          echo "Message: ${{ steps.status.outputs.message }}"
          echo "Environment: ${{ needs.pre-check.outputs.env }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Run ID: ${{ github.run_id }}"
          echo ""
          
          # Provide guidance based on trigger type
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "This was an AUTO-TRIGGER (CI success)"
            echo "Only plan was generated - no changes applied"
            echo "To apply: Use workflow_dispatch â†’ select deploy"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "This was a MANUAL TRIGGER"
            if [ "${{ needs.terraform-apply.result }}" = "success" ]; then
              echo "Changes have been APPLIED"
            elif [ "${{ needs.terraform-plan.outputs.has_changes }}" = "true" ]; then
              echo "Plan created - apply action was selected"
              echo "Waiting for environment approval..."
            fi
          fi
          echo "=========================================="